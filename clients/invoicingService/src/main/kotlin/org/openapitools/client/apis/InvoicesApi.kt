/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.EmptyEnvelope
import org.openapitools.client.models.ErrorEnvelope
import org.openapitools.client.models.ExtendedInvoiceDtoListEnvelope
import org.openapitools.client.models.Int32Envelope
import org.openapitools.client.models.InvoiceAdjustmentCreateDto
import org.openapitools.client.models.InvoiceAdjustmentDtoEnvelope
import org.openapitools.client.models.InvoiceAdjustmentDtoListEnvelope
import org.openapitools.client.models.InvoiceAdjustmentUpdateDto
import org.openapitools.client.models.InvoiceCreateDto
import org.openapitools.client.models.InvoiceDtoEnvelope
import org.openapitools.client.models.InvoiceDtoListEnvelope
import org.openapitools.client.models.InvoiceLineAppliedTaxCreateDto
import org.openapitools.client.models.InvoiceLineAppliedTaxDtoListEnvelope
import org.openapitools.client.models.InvoiceLineAppliedTaxUpdateDto
import org.openapitools.client.models.InvoiceLineCreateDto
import org.openapitools.client.models.InvoiceLineDtoEnvelope
import org.openapitools.client.models.InvoiceLineDtoListEnvelope
import org.openapitools.client.models.InvoiceLineUpdateDto
import org.openapitools.client.models.InvoiceReferenceCreateDto
import org.openapitools.client.models.InvoiceReferenceDtoEnvelope
import org.openapitools.client.models.InvoiceReferenceDtoListEnvelope
import org.openapitools.client.models.InvoiceReferenceUpdateDto
import org.openapitools.client.models.InvoiceUpdateDto
import org.openapitools.client.models.MoneyEnvelope

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class InvoicesApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * 
     * 
     * @param tenantId 
     * @return Int32Envelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesCountGet(tenantId: java.util.UUID) : Int32Envelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesCountGetWithHttpInfo(tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Int32Envelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param tenantId 
     * @return ApiResponse<Int32Envelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesCountGetWithHttpInfo(tenantId: java.util.UUID) : ApiResponse<Int32Envelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesCountGetRequestConfig(tenantId = tenantId)

        return request<Unit, Int32Envelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesCountGet
     *
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesCountGetRequestConfig(tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/Count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return MoneyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesDiscountsAggregatePost(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String? = null) : MoneyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesDiscountsAggregatePostWithHttpInfo(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MoneyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return ApiResponse<MoneyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesDiscountsAggregatePostWithHttpInfo(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : ApiResponse<MoneyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesDiscountsAggregatePostRequestConfig(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return request<kotlin.collections.List<java.util.UUID>, MoneyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesDiscountsAggregatePost
     *
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesDiscountsAggregatePostRequestConfig(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : RequestConfig<kotlin.collections.List<java.util.UUID>> {
        val localVariableBody = javaUtilUUID
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currencyId != null) {
                    put("currencyId", listOf(currencyId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices/DiscountsAggregate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param tenantId 
     * @return Int32Envelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesExtendedCountGet(tenantId: java.util.UUID) : Int32Envelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesExtendedCountGetWithHttpInfo(tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Int32Envelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param tenantId 
     * @return ApiResponse<Int32Envelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesExtendedCountGetWithHttpInfo(tenantId: java.util.UUID) : ApiResponse<Int32Envelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesExtendedCountGetRequestConfig(tenantId = tenantId)

        return request<Unit, Int32Envelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesExtendedCountGet
     *
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesExtendedCountGetRequestConfig(tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/Extended/Count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param tenantId 
     * @return ExtendedInvoiceDtoListEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesExtendedGet(tenantId: java.util.UUID) : ExtendedInvoiceDtoListEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesExtendedGetWithHttpInfo(tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExtendedInvoiceDtoListEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param tenantId 
     * @return ApiResponse<ExtendedInvoiceDtoListEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesExtendedGetWithHttpInfo(tenantId: java.util.UUID) : ApiResponse<ExtendedInvoiceDtoListEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesExtendedGetRequestConfig(tenantId = tenantId)

        return request<Unit, ExtendedInvoiceDtoListEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesExtendedGet
     *
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesExtendedGetRequestConfig(tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/Extended",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param tenantId 
     * @return InvoiceDtoListEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesGet(tenantId: java.util.UUID) : InvoiceDtoListEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesGetWithHttpInfo(tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceDtoListEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param tenantId 
     * @return ApiResponse<InvoiceDtoListEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesGetWithHttpInfo(tenantId: java.util.UUID) : ApiResponse<InvoiceDtoListEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesGetRequestConfig(tenantId = tenantId)

        return request<Unit, InvoiceDtoListEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesGet
     *
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesGetRequestConfig(tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return MoneyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePost(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String? = null) : MoneyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostWithHttpInfo(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MoneyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return ApiResponse<MoneyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostWithHttpInfo(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : ApiResponse<MoneyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequestConfig(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return request<kotlin.collections.List<java.util.UUID>, MoneyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePost
     *
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequestConfig(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : RequestConfig<kotlin.collections.List<java.util.UUID>> {
        val localVariableBody = javaUtilUUID
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currencyId != null) {
                    put("currencyId", listOf(currencyId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices/GlobalSurchargesAggregate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return Int32Envelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGet(invoiceId: java.util.UUID, tenantId: java.util.UUID) : Int32Envelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Int32Envelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return ApiResponse<Int32Envelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<Int32Envelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequestConfig(invoiceId = invoiceId, tenantId = tenantId)

        return request<Unit, Int32Envelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGet
     *
     * @param invoiceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments/Count".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return InvoiceAdjustmentDtoListEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGet(invoiceId: java.util.UUID, tenantId: java.util.UUID) : InvoiceAdjustmentDtoListEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceAdjustmentDtoListEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return ApiResponse<InvoiceAdjustmentDtoListEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<InvoiceAdjustmentDtoListEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequestConfig(invoiceId = invoiceId, tenantId = tenantId)

        return request<Unit, InvoiceAdjustmentDtoListEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGet
     *
     * @param invoiceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceAdjustmentId 
     * @param tenantId 
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDelete(invoiceId: java.util.UUID, invoiceAdjustmentId: java.util.UUID, tenantId: java.util.UUID) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteWithHttpInfo(invoiceId = invoiceId, invoiceAdjustmentId = invoiceAdjustmentId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceAdjustmentId 
     * @param tenantId 
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteWithHttpInfo(invoiceId: java.util.UUID, invoiceAdjustmentId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequestConfig(invoiceId = invoiceId, invoiceAdjustmentId = invoiceAdjustmentId, tenantId = tenantId)

        return request<Unit, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDelete
     *
     * @param invoiceId 
     * @param invoiceAdjustmentId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequestConfig(invoiceId: java.util.UUID, invoiceAdjustmentId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments/{invoiceAdjustmentId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceAdjustmentId"+"}", encodeURIComponent(invoiceAdjustmentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceAdjustmentId 
     * @param tenantId 
     * @return InvoiceAdjustmentDtoEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGet(invoiceId: java.util.UUID, invoiceAdjustmentId: java.util.UUID, tenantId: java.util.UUID) : InvoiceAdjustmentDtoEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetWithHttpInfo(invoiceId = invoiceId, invoiceAdjustmentId = invoiceAdjustmentId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceAdjustmentDtoEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceAdjustmentId 
     * @param tenantId 
     * @return ApiResponse<InvoiceAdjustmentDtoEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetWithHttpInfo(invoiceId: java.util.UUID, invoiceAdjustmentId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<InvoiceAdjustmentDtoEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequestConfig(invoiceId = invoiceId, invoiceAdjustmentId = invoiceAdjustmentId, tenantId = tenantId)

        return request<Unit, InvoiceAdjustmentDtoEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGet
     *
     * @param invoiceId 
     * @param invoiceAdjustmentId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequestConfig(invoiceId: java.util.UUID, invoiceAdjustmentId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments/{invoiceAdjustmentId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceAdjustmentId"+"}", encodeURIComponent(invoiceAdjustmentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceAdjustmentId 
     * @param tenantId 
     * @param invoiceAdjustmentUpdateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPut(invoiceId: java.util.UUID, invoiceAdjustmentId: java.util.UUID, tenantId: java.util.UUID, invoiceAdjustmentUpdateDto: InvoiceAdjustmentUpdateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutWithHttpInfo(invoiceId = invoiceId, invoiceAdjustmentId = invoiceAdjustmentId, tenantId = tenantId, invoiceAdjustmentUpdateDto = invoiceAdjustmentUpdateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceAdjustmentId 
     * @param tenantId 
     * @param invoiceAdjustmentUpdateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutWithHttpInfo(invoiceId: java.util.UUID, invoiceAdjustmentId: java.util.UUID, tenantId: java.util.UUID, invoiceAdjustmentUpdateDto: InvoiceAdjustmentUpdateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequestConfig(invoiceId = invoiceId, invoiceAdjustmentId = invoiceAdjustmentId, tenantId = tenantId, invoiceAdjustmentUpdateDto = invoiceAdjustmentUpdateDto)

        return request<InvoiceAdjustmentUpdateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPut
     *
     * @param invoiceId 
     * @param invoiceAdjustmentId 
     * @param tenantId 
     * @param invoiceAdjustmentUpdateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequestConfig(invoiceId: java.util.UUID, invoiceAdjustmentId: java.util.UUID, tenantId: java.util.UUID, invoiceAdjustmentUpdateDto: InvoiceAdjustmentUpdateDto?) : RequestConfig<InvoiceAdjustmentUpdateDto> {
        val localVariableBody = invoiceAdjustmentUpdateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments/{invoiceAdjustmentId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceAdjustmentId"+"}", encodeURIComponent(invoiceAdjustmentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceAdjustmentCreateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPost(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceAdjustmentCreateDto: InvoiceAdjustmentCreateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId, invoiceAdjustmentCreateDto = invoiceAdjustmentCreateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceAdjustmentCreateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceAdjustmentCreateDto: InvoiceAdjustmentCreateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequestConfig(invoiceId = invoiceId, tenantId = tenantId, invoiceAdjustmentCreateDto = invoiceAdjustmentCreateDto)

        return request<InvoiceAdjustmentCreateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPost
     *
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceAdjustmentCreateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceAdjustmentCreateDto: InvoiceAdjustmentCreateDto?) : RequestConfig<InvoiceAdjustmentCreateDto> {
        val localVariableBody = invoiceAdjustmentCreateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdCalculatePut(invoiceId: java.util.UUID, tenantId: java.util.UUID) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdCalculatePutWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdCalculatePutWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequestConfig(invoiceId = invoiceId, tenantId = tenantId)

        return request<Unit, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdCalculatePut
     *
     * @param invoiceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Calculate".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdDelete(invoiceId: java.util.UUID, tenantId: java.util.UUID) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdDeleteWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdDeleteWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdDeleteRequestConfig(invoiceId = invoiceId, tenantId = tenantId)

        return request<Unit, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdDelete
     *
     * @param invoiceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdDeleteRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return InvoiceDtoEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdExtendedGet(invoiceId: java.util.UUID, tenantId: java.util.UUID) : InvoiceDtoEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdExtendedGetWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceDtoEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return ApiResponse<InvoiceDtoEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdExtendedGetWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<InvoiceDtoEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequestConfig(invoiceId = invoiceId, tenantId = tenantId)

        return request<Unit, InvoiceDtoEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdExtendedGet
     *
     * @param invoiceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Extended".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return Int32Envelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesCountGet(invoiceId: java.util.UUID, tenantId: java.util.UUID) : Int32Envelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Int32Envelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return ApiResponse<Int32Envelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<Int32Envelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequestConfig(invoiceId = invoiceId, tenantId = tenantId)

        return request<Unit, Int32Envelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesCountGet
     *
     * @param invoiceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/Count".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param itemId  (optional)
     * @return InvoiceLineDtoListEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesGet(invoiceId: java.util.UUID, tenantId: java.util.UUID, itemId: java.util.UUID? = null) : InvoiceLineDtoListEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesGetWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId, itemId = itemId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceLineDtoListEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param itemId  (optional)
     * @return ApiResponse<InvoiceLineDtoListEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesGetWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID, itemId: java.util.UUID?) : ApiResponse<InvoiceLineDtoListEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequestConfig(invoiceId = invoiceId, tenantId = tenantId, itemId = itemId)

        return request<Unit, InvoiceLineDtoListEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesGet
     *
     * @param invoiceId 
     * @param tenantId 
     * @param itemId  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID, itemId: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
                if (itemId != null) {
                    put("itemId", listOf(itemId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePut(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutWithHttpInfo(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutWithHttpInfo(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequestConfig(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return request<Unit, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePut
     *
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequestConfig(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Calculate".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceLineId"+"}", encodeURIComponent(invoiceLineId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDelete(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteWithHttpInfo(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteWithHttpInfo(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequestConfig(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return request<Unit, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDelete
     *
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequestConfig(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceLineId"+"}", encodeURIComponent(invoiceLineId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return InvoiceLineDtoEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGet(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : InvoiceLineDtoEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetWithHttpInfo(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceLineDtoEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return ApiResponse<InvoiceLineDtoEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetWithHttpInfo(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<InvoiceLineDtoEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequestConfig(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return request<Unit, InvoiceLineDtoEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGet
     *
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequestConfig(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceLineId"+"}", encodeURIComponent(invoiceLineId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @param invoiceLineUpdateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPut(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID, invoiceLineUpdateDto: InvoiceLineUpdateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutWithHttpInfo(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId, invoiceLineUpdateDto = invoiceLineUpdateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @param invoiceLineUpdateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutWithHttpInfo(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID, invoiceLineUpdateDto: InvoiceLineUpdateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequestConfig(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId, invoiceLineUpdateDto = invoiceLineUpdateDto)

        return request<InvoiceLineUpdateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPut
     *
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @param invoiceLineUpdateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequestConfig(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID, invoiceLineUpdateDto: InvoiceLineUpdateDto?) : RequestConfig<InvoiceLineUpdateDto> {
        val localVariableBody = invoiceLineUpdateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceLineId"+"}", encodeURIComponent(invoiceLineId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return Int32Envelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGet(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : Int32Envelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetWithHttpInfo(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Int32Envelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return ApiResponse<Int32Envelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetWithHttpInfo(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<Int32Envelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequestConfig(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return request<Unit, Int32Envelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGet
     *
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequestConfig(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes/Count".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceLineId"+"}", encodeURIComponent(invoiceLineId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return InvoiceLineAppliedTaxDtoListEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGet(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : InvoiceLineAppliedTaxDtoListEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetWithHttpInfo(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceLineAppliedTaxDtoListEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return ApiResponse<InvoiceLineAppliedTaxDtoListEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetWithHttpInfo(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<InvoiceLineAppliedTaxDtoListEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequestConfig(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId)

        return request<Unit, InvoiceLineAppliedTaxDtoListEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGet
     *
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequestConfig(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceLineId"+"}", encodeURIComponent(invoiceLineId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param invoiceLineTaxId 
     * @param tenantId 
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDelete(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, invoiceLineTaxId: java.util.UUID, tenantId: java.util.UUID) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteWithHttpInfo(invoiceId = invoiceId, invoiceLineId = invoiceLineId, invoiceLineTaxId = invoiceLineTaxId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param invoiceLineTaxId 
     * @param tenantId 
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteWithHttpInfo(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, invoiceLineTaxId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequestConfig(invoiceId = invoiceId, invoiceLineId = invoiceLineId, invoiceLineTaxId = invoiceLineTaxId, tenantId = tenantId)

        return request<Unit, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDelete
     *
     * @param invoiceId 
     * @param invoiceLineId 
     * @param invoiceLineTaxId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequestConfig(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, invoiceLineTaxId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes/{invoiceLineTaxId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceLineId"+"}", encodeURIComponent(invoiceLineId.toString())).replace("{"+"invoiceLineTaxId"+"}", encodeURIComponent(invoiceLineTaxId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param invoiceLineTaxId 
     * @param tenantId 
     * @param invoiceLineAppliedTaxUpdateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPut(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, invoiceLineTaxId: java.util.UUID, tenantId: java.util.UUID, invoiceLineAppliedTaxUpdateDto: InvoiceLineAppliedTaxUpdateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutWithHttpInfo(invoiceId = invoiceId, invoiceLineId = invoiceLineId, invoiceLineTaxId = invoiceLineTaxId, tenantId = tenantId, invoiceLineAppliedTaxUpdateDto = invoiceLineAppliedTaxUpdateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param invoiceLineTaxId 
     * @param tenantId 
     * @param invoiceLineAppliedTaxUpdateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutWithHttpInfo(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, invoiceLineTaxId: java.util.UUID, tenantId: java.util.UUID, invoiceLineAppliedTaxUpdateDto: InvoiceLineAppliedTaxUpdateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequestConfig(invoiceId = invoiceId, invoiceLineId = invoiceLineId, invoiceLineTaxId = invoiceLineTaxId, tenantId = tenantId, invoiceLineAppliedTaxUpdateDto = invoiceLineAppliedTaxUpdateDto)

        return request<InvoiceLineAppliedTaxUpdateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPut
     *
     * @param invoiceId 
     * @param invoiceLineId 
     * @param invoiceLineTaxId 
     * @param tenantId 
     * @param invoiceLineAppliedTaxUpdateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequestConfig(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, invoiceLineTaxId: java.util.UUID, tenantId: java.util.UUID, invoiceLineAppliedTaxUpdateDto: InvoiceLineAppliedTaxUpdateDto?) : RequestConfig<InvoiceLineAppliedTaxUpdateDto> {
        val localVariableBody = invoiceLineAppliedTaxUpdateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes/{invoiceLineTaxId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceLineId"+"}", encodeURIComponent(invoiceLineId.toString())).replace("{"+"invoiceLineTaxId"+"}", encodeURIComponent(invoiceLineTaxId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @param invoiceLineAppliedTaxCreateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPost(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID, invoiceLineAppliedTaxCreateDto: InvoiceLineAppliedTaxCreateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostWithHttpInfo(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId, invoiceLineAppliedTaxCreateDto = invoiceLineAppliedTaxCreateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @param invoiceLineAppliedTaxCreateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostWithHttpInfo(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID, invoiceLineAppliedTaxCreateDto: InvoiceLineAppliedTaxCreateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequestConfig(invoiceId = invoiceId, invoiceLineId = invoiceLineId, tenantId = tenantId, invoiceLineAppliedTaxCreateDto = invoiceLineAppliedTaxCreateDto)

        return request<InvoiceLineAppliedTaxCreateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPost
     *
     * @param invoiceId 
     * @param invoiceLineId 
     * @param tenantId 
     * @param invoiceLineAppliedTaxCreateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequestConfig(invoiceId: java.util.UUID, invoiceLineId: java.util.UUID, tenantId: java.util.UUID, invoiceLineAppliedTaxCreateDto: InvoiceLineAppliedTaxCreateDto?) : RequestConfig<InvoiceLineAppliedTaxCreateDto> {
        val localVariableBody = invoiceLineAppliedTaxCreateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceLineId"+"}", encodeURIComponent(invoiceLineId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceLineCreateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesPost(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceLineCreateDto: InvoiceLineCreateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdLinesPostWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId, invoiceLineCreateDto = invoiceLineCreateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceLineCreateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesPostWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceLineCreateDto: InvoiceLineCreateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequestConfig(invoiceId = invoiceId, tenantId = tenantId, invoiceLineCreateDto = invoiceLineCreateDto)

        return request<InvoiceLineCreateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdLinesPost
     *
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceLineCreateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceLineCreateDto: InvoiceLineCreateDto?) : RequestConfig<InvoiceLineCreateDto> {
        val localVariableBody = invoiceLineCreateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @return Int32Envelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGet(invoiceId: java.util.UUID) : Int32Envelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetWithHttpInfo(invoiceId = invoiceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Int32Envelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @return ApiResponse<Int32Envelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetWithHttpInfo(invoiceId: java.util.UUID) : ApiResponse<Int32Envelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetRequestConfig(invoiceId = invoiceId)

        return request<Unit, Int32Envelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGet
     *
     * @param invoiceId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetRequestConfig(invoiceId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Payments/Count".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @return InvoiceDtoListEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdPaymentsGet(invoiceId: java.util.UUID) : InvoiceDtoListEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetWithHttpInfo(invoiceId = invoiceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceDtoListEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @return ApiResponse<InvoiceDtoListEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetWithHttpInfo(invoiceId: java.util.UUID) : ApiResponse<InvoiceDtoListEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetRequestConfig(invoiceId = invoiceId)

        return request<Unit, InvoiceDtoListEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdPaymentsGet
     *
     * @param invoiceId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetRequestConfig(invoiceId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/Payments".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceUpdateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdPut(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceUpdateDto: InvoiceUpdateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdPutWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId, invoiceUpdateDto = invoiceUpdateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceUpdateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdPutWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceUpdateDto: InvoiceUpdateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdPutRequestConfig(invoiceId = invoiceId, tenantId = tenantId, invoiceUpdateDto = invoiceUpdateDto)

        return request<InvoiceUpdateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdPut
     *
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceUpdateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdPutRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceUpdateDto: InvoiceUpdateDto?) : RequestConfig<InvoiceUpdateDto> {
        val localVariableBody = invoiceUpdateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return Int32Envelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGet(invoiceId: java.util.UUID, tenantId: java.util.UUID) : Int32Envelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Int32Envelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return ApiResponse<Int32Envelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<Int32Envelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequestConfig(invoiceId = invoiceId, tenantId = tenantId)

        return request<Unit, Int32Envelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGet
     *
     * @param invoiceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/References/Count".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return InvoiceReferenceDtoListEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesGet(invoiceId: java.util.UUID, tenantId: java.util.UUID) : InvoiceReferenceDtoListEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdReferencesGetWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceReferenceDtoListEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return ApiResponse<InvoiceReferenceDtoListEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesGetWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<InvoiceReferenceDtoListEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequestConfig(invoiceId = invoiceId, tenantId = tenantId)

        return request<Unit, InvoiceReferenceDtoListEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdReferencesGet
     *
     * @param invoiceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/References".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceReferenceId 
     * @param tenantId 
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDelete(invoiceId: java.util.UUID, invoiceReferenceId: java.util.UUID, tenantId: java.util.UUID) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteWithHttpInfo(invoiceId = invoiceId, invoiceReferenceId = invoiceReferenceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceReferenceId 
     * @param tenantId 
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteWithHttpInfo(invoiceId: java.util.UUID, invoiceReferenceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequestConfig(invoiceId = invoiceId, invoiceReferenceId = invoiceReferenceId, tenantId = tenantId)

        return request<Unit, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDelete
     *
     * @param invoiceId 
     * @param invoiceReferenceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequestConfig(invoiceId: java.util.UUID, invoiceReferenceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/References/{invoiceReferenceId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceReferenceId"+"}", encodeURIComponent(invoiceReferenceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceReferenceId 
     * @param tenantId 
     * @return InvoiceReferenceDtoEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGet(invoiceId: java.util.UUID, invoiceReferenceId: java.util.UUID, tenantId: java.util.UUID) : InvoiceReferenceDtoEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetWithHttpInfo(invoiceId = invoiceId, invoiceReferenceId = invoiceReferenceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceReferenceDtoEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceReferenceId 
     * @param tenantId 
     * @return ApiResponse<InvoiceReferenceDtoEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetWithHttpInfo(invoiceId: java.util.UUID, invoiceReferenceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<InvoiceReferenceDtoEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequestConfig(invoiceId = invoiceId, invoiceReferenceId = invoiceReferenceId, tenantId = tenantId)

        return request<Unit, InvoiceReferenceDtoEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGet
     *
     * @param invoiceId 
     * @param invoiceReferenceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequestConfig(invoiceId: java.util.UUID, invoiceReferenceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/References/{invoiceReferenceId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceReferenceId"+"}", encodeURIComponent(invoiceReferenceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceReferenceId 
     * @param tenantId 
     * @param invoiceReferenceUpdateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPut(invoiceId: java.util.UUID, invoiceReferenceId: java.util.UUID, tenantId: java.util.UUID, invoiceReferenceUpdateDto: InvoiceReferenceUpdateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutWithHttpInfo(invoiceId = invoiceId, invoiceReferenceId = invoiceReferenceId, tenantId = tenantId, invoiceReferenceUpdateDto = invoiceReferenceUpdateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param invoiceReferenceId 
     * @param tenantId 
     * @param invoiceReferenceUpdateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutWithHttpInfo(invoiceId: java.util.UUID, invoiceReferenceId: java.util.UUID, tenantId: java.util.UUID, invoiceReferenceUpdateDto: InvoiceReferenceUpdateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequestConfig(invoiceId = invoiceId, invoiceReferenceId = invoiceReferenceId, tenantId = tenantId, invoiceReferenceUpdateDto = invoiceReferenceUpdateDto)

        return request<InvoiceReferenceUpdateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPut
     *
     * @param invoiceId 
     * @param invoiceReferenceId 
     * @param tenantId 
     * @param invoiceReferenceUpdateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequestConfig(invoiceId: java.util.UUID, invoiceReferenceId: java.util.UUID, tenantId: java.util.UUID, invoiceReferenceUpdateDto: InvoiceReferenceUpdateDto?) : RequestConfig<InvoiceReferenceUpdateDto> {
        val localVariableBody = invoiceReferenceUpdateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/References/{invoiceReferenceId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())).replace("{"+"invoiceReferenceId"+"}", encodeURIComponent(invoiceReferenceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceReferenceCreateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesPost(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceReferenceCreateDto: InvoiceReferenceCreateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesInvoiceIdReferencesPostWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId, invoiceReferenceCreateDto = invoiceReferenceCreateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceReferenceCreateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesPostWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceReferenceCreateDto: InvoiceReferenceCreateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequestConfig(invoiceId = invoiceId, tenantId = tenantId, invoiceReferenceCreateDto = invoiceReferenceCreateDto)

        return request<InvoiceReferenceCreateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesInvoiceIdReferencesPost
     *
     * @param invoiceId 
     * @param tenantId 
     * @param invoiceReferenceCreateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID, invoiceReferenceCreateDto: InvoiceReferenceCreateDto?) : RequestConfig<InvoiceReferenceCreateDto> {
        val localVariableBody = invoiceReferenceCreateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}/References".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param tenantId 
     * @param invoiceCreateDto  (optional)
     * @return EmptyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesPost(tenantId: java.util.UUID, invoiceCreateDto: InvoiceCreateDto? = null) : EmptyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesPostWithHttpInfo(tenantId = tenantId, invoiceCreateDto = invoiceCreateDto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmptyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param tenantId 
     * @param invoiceCreateDto  (optional)
     * @return ApiResponse<EmptyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesPostWithHttpInfo(tenantId: java.util.UUID, invoiceCreateDto: InvoiceCreateDto?) : ApiResponse<EmptyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesPostRequestConfig(tenantId = tenantId, invoiceCreateDto = invoiceCreateDto)

        return request<InvoiceCreateDto, EmptyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesPost
     *
     * @param tenantId 
     * @param invoiceCreateDto  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesPostRequestConfig(tenantId: java.util.UUID, invoiceCreateDto: InvoiceCreateDto?) : RequestConfig<InvoiceCreateDto> {
        val localVariableBody = invoiceCreateDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return MoneyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesTaxBasesAggregatePost(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String? = null) : MoneyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesTaxBasesAggregatePostWithHttpInfo(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MoneyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return ApiResponse<MoneyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesTaxBasesAggregatePostWithHttpInfo(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : ApiResponse<MoneyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequestConfig(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return request<kotlin.collections.List<java.util.UUID>, MoneyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesTaxBasesAggregatePost
     *
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequestConfig(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : RequestConfig<kotlin.collections.List<java.util.UUID>> {
        val localVariableBody = javaUtilUUID
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currencyId != null) {
                    put("currencyId", listOf(currencyId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices/TaxBasesAggregate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return MoneyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesTaxesAggregatePost(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String? = null) : MoneyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesTaxesAggregatePostWithHttpInfo(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MoneyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return ApiResponse<MoneyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesTaxesAggregatePostWithHttpInfo(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : ApiResponse<MoneyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesTaxesAggregatePostRequestConfig(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return request<kotlin.collections.List<java.util.UUID>, MoneyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesTaxesAggregatePost
     *
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesTaxesAggregatePostRequestConfig(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : RequestConfig<kotlin.collections.List<java.util.UUID>> {
        val localVariableBody = javaUtilUUID
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currencyId != null) {
                    put("currencyId", listOf(currencyId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices/TaxesAggregate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return MoneyEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2InvoicingServiceInvoicesTotalsAggregatePost(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String? = null) : MoneyEnvelope {
        val localVarResponse = apiV2InvoicingServiceInvoicesTotalsAggregatePostWithHttpInfo(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MoneyEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return ApiResponse<MoneyEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2InvoicingServiceInvoicesTotalsAggregatePostWithHttpInfo(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : ApiResponse<MoneyEnvelope?> {
        val localVariableConfig = apiV2InvoicingServiceInvoicesTotalsAggregatePostRequestConfig(javaUtilUUID = javaUtilUUID, currencyId = currencyId)

        return request<kotlin.collections.List<java.util.UUID>, MoneyEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2InvoicingServiceInvoicesTotalsAggregatePost
     *
     * @param javaUtilUUID 
     * @param currencyId  (optional)
     * @return RequestConfig
     */
    fun apiV2InvoicingServiceInvoicesTotalsAggregatePostRequestConfig(javaUtilUUID: kotlin.collections.List<java.util.UUID>, currencyId: kotlin.String?) : RequestConfig<kotlin.collections.List<java.util.UUID>> {
        val localVariableBody = javaUtilUUID
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currencyId != null) {
                    put("currencyId", listOf(currencyId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/InvoicingService/Invoices/TotalsAggregate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return InvoiceDtoEnvelope
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getInvoiceAsync(invoiceId: java.util.UUID, tenantId: java.util.UUID) : InvoiceDtoEnvelope {
        val localVarResponse = getInvoiceAsyncWithHttpInfo(invoiceId = invoiceId, tenantId = tenantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvoiceDtoEnvelope
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param invoiceId 
     * @param tenantId 
     * @return ApiResponse<InvoiceDtoEnvelope?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getInvoiceAsyncWithHttpInfo(invoiceId: java.util.UUID, tenantId: java.util.UUID) : ApiResponse<InvoiceDtoEnvelope?> {
        val localVariableConfig = getInvoiceAsyncRequestConfig(invoiceId = invoiceId, tenantId = tenantId)

        return request<Unit, InvoiceDtoEnvelope>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getInvoiceAsync
     *
     * @param invoiceId 
     * @param tenantId 
     * @return RequestConfig
     */
    fun getInvoiceAsyncRequestConfig(invoiceId: java.util.UUID, tenantId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tenantId", listOf(tenantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/InvoicingService/Invoices/{invoiceId}".replace("{"+"invoiceId"+"}", encodeURIComponent(invoiceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
